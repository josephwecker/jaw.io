---
title: "Beyond Erlang Actors, Part 1"
subtitle: "Kahn Process Networks"
draft: true
date: 2013/12/23
tags: erlang, kahn-process-networks, parallel
---

_It's one thing to have awesome Actors. It's another thing to put together a well-behaved pipeline for processing data in
parallel and even in a distributed environment._

READMORE

The most obvious starting point for deciding when you want something like a Kahn network is any time you find yourself
thinking in terms of a unix pipeline- data needing sequential processing, ideally with the additional ability to split
down separate paths and join back up later. These sorts of problems come up often in signal processing, input/output
transformations, complex event processing, "bit-shoveling," almost any problem that lends itself to distributed
computing, etc. In fact, with apologies to Greenspun, many Erlang systems end up as ad-hoc, informally-specified,
bug-ridden implementations of Kahn Process Networks.

A Kahn Network is best for any problem that makes the most sense as a data-flow model- as streams of data flowing
through various stages (possibly in parallel). Like the unix pipeline, it allows you develop the stages (processes- or,
in Erlang terminology, things you would normally supervise like gen_servers and gen_fsms) individually, in a very
functional way- optimizing abstraction, reuse, testability, and usually keeping the system simple and intuitive.

I will be logging the development of the Erlang Kahn library here as I go because it illustrates many important aspects
of the Erlang ecosystem and distributed computation. Because these are blog entries in the original sense of the word
(web-log), everything is subject to change. If you're just interested in using the final product as it currently stands,
head over to https://github.com/josephwecker/kahn for the simplified version of usage etc.
